# US-011: Request Routing & Failover

## Story Details

| Field | Value |
|-------|-------|
| **Story ID** | US-011 |
| **Epic** | EPIC-GATEWAY |
| **Title** | Request Routing & Failover |
| **Priority** | Critical |
| **Story Points** | 8 |
| **Status** | Ready |
| **Assignee** | Unassigned |
| **Sprint** | Sprint 1 |

## User Story

**As a** platform operator,
**I want** intelligent request routing with automatic failover,
**So that** service remains available even when individual LLM providers experience outages.

## Description

Implement a request routing system that directs LLM requests to the appropriate provider based on configuration, availability, and cost. Include automatic failover to backup providers when the primary provider fails, with circuit breaker patterns to prevent cascade failures.

## Acceptance Criteria

- [ ] Requests routed to configured default provider
- [ ] Automatic failover to next provider on failure
- [ ] Failover order configurable via environment variables
- [ ] Circuit breaker opens after N consecutive failures
- [ ] Circuit breaker half-open state for recovery testing
- [ ] Retry with exponential backoff before failover
- [ ] Provider health tracked in real-time
- [ ] Failover occurs within 5 seconds
- [ ] Metrics emitted for routing decisions
- [ ] Logging for all failover events

## Technical Notes

### IEEE Requirement References
- IEEE-STD-GW-002: Request Handling

### Router Implementation

```typescript
// services/router/index.ts
export class RequestRouter {
  private providers: ProviderRegistry;
  private circuitBreakers: Map<string, CircuitBreaker>;
  private config: RouterConfig;

  constructor(providers: ProviderRegistry, config: RouterConfig) {
    this.providers = providers;
    this.config = config;
    this.circuitBreakers = new Map();

    // Initialize circuit breakers for each provider
    for (const name of providers.list()) {
      this.circuitBreakers.set(name, new CircuitBreaker({
        failureThreshold: config.failureThreshold,
        resetTimeout: config.circuitResetTimeout,
      }));
    }
  }

  async route(request: ChatRequest): Promise<ChatResponse> {
    const providerOrder = this.getProviderOrder(request);

    for (const providerName of providerOrder) {
      const provider = this.providers.get(providerName);
      const circuitBreaker = this.circuitBreakers.get(providerName);

      if (!provider || !circuitBreaker) continue;
      if (circuitBreaker.isOpen()) {
        logger.info(`Circuit breaker open for ${providerName}, skipping`);
        continue;
      }

      try {
        const response = await this.executeWithRetry(provider, request);
        circuitBreaker.recordSuccess();
        return response;
      } catch (error) {
        circuitBreaker.recordFailure();
        logger.error(`Provider ${providerName} failed`, { error });
        metrics.increment('provider_failover', { from: providerName });
      }
    }

    throw new Error('All providers failed');
  }

  private getProviderOrder(request: ChatRequest): string[] {
    // Start with default provider
    const order = [this.config.defaultProvider];

    // Add fallback providers
    order.push(...this.config.fallbackProviders);

    return order;
  }

  private async executeWithRetry(
    provider: LLMProvider,
    request: ChatRequest,
    maxRetries = 3
  ): Promise<ChatResponse> {
    for (let attempt = 0; attempt < maxRetries; attempt++) {
      try {
        return await provider.chat(request);
      } catch (error) {
        if (!this.isRetryable(error) || attempt === maxRetries - 1) {
          throw error;
        }
        await this.delay(Math.pow(2, attempt) * 1000); // Exponential backoff
      }
    }
    throw new Error('Max retries exceeded');
  }
}
```

### Circuit Breaker

```typescript
// services/router/circuit-breaker.ts
export class CircuitBreaker {
  private state: 'closed' | 'open' | 'half-open' = 'closed';
  private failures = 0;
  private lastFailureTime: number | null = null;
  private config: CircuitBreakerConfig;

  constructor(config: CircuitBreakerConfig) {
    this.config = config;
  }

  isOpen(): boolean {
    if (this.state === 'closed') return false;
    if (this.state === 'open') {
      // Check if we should transition to half-open
      if (Date.now() - this.lastFailureTime! > this.config.resetTimeout) {
        this.state = 'half-open';
        return false;
      }
      return true;
    }
    return false; // half-open allows one request through
  }

  recordSuccess(): void {
    this.failures = 0;
    this.state = 'closed';
  }

  recordFailure(): void {
    this.failures++;
    this.lastFailureTime = Date.now();
    if (this.failures >= this.config.failureThreshold) {
      this.state = 'open';
    }
  }
}
```

### Configuration

```typescript
// config/router.ts
export const routerConfig: RouterConfig = {
  defaultProvider: process.env.LLM_PROVIDER || 'anthropic',
  fallbackProviders: (process.env.LLM_FALLBACK_PROVIDERS || 'openai,groq')
    .split(',')
    .map(p => p.trim()),
  failureThreshold: 3,
  circuitResetTimeout: 30000, // 30 seconds
  maxRetries: 3,
};
```

### Files to Create/Modify
- `apps/gateway/services/router/index.ts`
- `apps/gateway/services/router/circuit-breaker.ts`
- `apps/gateway/config/router.ts`

## Dependencies

- LLM Provider abstraction layer (US-010)
- Redis for distributed circuit breaker state (optional)

## Definition of Done

- [ ] Router correctly routes to default provider
- [ ] Failover occurs on provider failure
- [ ] Circuit breaker prevents repeated failures
- [ ] Exponential backoff working
- [ ] Metrics and logging in place
- [ ] Integration tests for failover scenarios
- [ ] Performance benchmarks acceptable (<100ms overhead)

---

*Created: 2026-02-08*
