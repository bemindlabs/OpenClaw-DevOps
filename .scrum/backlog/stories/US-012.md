# US-012: Rate Limiting Implementation

## Story Details

| Field | Value |
|-------|-------|
| **Story ID** | US-012 |
| **Epic** | EPIC-GATEWAY |
| **Title** | Rate Limiting Implementation |
| **Priority** | High |
| **Story Points** | 5 |
| **Status** | Ready |
| **Assignee** | Unassigned |
| **Sprint** | Sprint 2 |

## User Story

**As a** platform operator,
**I want** rate limiting on API requests,
**So that** I can prevent abuse and ensure fair usage across all users.

## Description

Implement a Redis-backed rate limiting system using the token bucket algorithm. Support per-user and per-API-key limits, with configurable thresholds and time windows. Return appropriate headers indicating rate limit status.

## Acceptance Criteria

- [ ] Token bucket algorithm implemented
- [ ] Redis-backed for distributed limiting
- [ ] Per-user rate limits enforced
- [ ] Per-API-key rate limits enforced
- [ ] Configurable limits (requests/minute, tokens/hour)
- [ ] Rate limit headers returned (X-RateLimit-*)
- [ ] 429 Too Many Requests on limit exceeded
- [ ] Retry-After header included on 429
- [ ] Graceful degradation if Redis unavailable
- [ ] Metrics for rate limit events

## Technical Notes

### IEEE Requirement References
- IEEE-STD-GW-003: Rate Limiting

### Rate Limiter Implementation

```typescript
// services/rate-limiter/index.ts
import Redis from 'ioredis';

export interface RateLimitConfig {
  requests: number;      // Number of requests
  window: number;        // Time window in seconds
  burstSize?: number;    // Allow burst up to this size
}

export class RateLimiter {
  private redis: Redis;
  private config: RateLimitConfig;

  constructor(redis: Redis, config: RateLimitConfig) {
    this.redis = redis;
    this.config = config;
  }

  async consume(key: string, cost = 1): Promise<RateLimitResult> {
    const now = Date.now();
    const windowStart = now - (this.config.window * 1000);
    const redisKey = `ratelimit:${key}`;

    // Token bucket using Redis sorted set
    const pipeline = this.redis.pipeline();

    // Remove old entries
    pipeline.zremrangebyscore(redisKey, 0, windowStart);

    // Count current entries
    pipeline.zcard(redisKey);

    // Add new entry
    pipeline.zadd(redisKey, now, `${now}:${Math.random()}`);

    // Set expiry
    pipeline.expire(redisKey, this.config.window);

    const results = await pipeline.exec();
    const currentCount = results[1][1] as number;

    const remaining = Math.max(0, this.config.requests - currentCount - cost);
    const resetAt = new Date(now + this.config.window * 1000);

    if (currentCount >= this.config.requests) {
      // Rate limit exceeded
      const retryAfter = Math.ceil((windowStart + this.config.window * 1000 - now) / 1000);

      return {
        allowed: false,
        remaining: 0,
        limit: this.config.requests,
        resetAt,
        retryAfter,
      };
    }

    return {
      allowed: true,
      remaining,
      limit: this.config.requests,
      resetAt,
    };
  }
}

export interface RateLimitResult {
  allowed: boolean;
  remaining: number;
  limit: number;
  resetAt: Date;
  retryAfter?: number;
}
```

### Middleware

```typescript
// middleware/rate-limit.ts
export function rateLimitMiddleware(limiter: RateLimiter) {
  return async (req: Request, res: Response, next: NextFunction) => {
    const key = req.user?.id || req.ip;
    const result = await limiter.consume(key);

    // Set rate limit headers
    res.setHeader('X-RateLimit-Limit', result.limit);
    res.setHeader('X-RateLimit-Remaining', result.remaining);
    res.setHeader('X-RateLimit-Reset', result.resetAt.toISOString());

    if (!result.allowed) {
      res.setHeader('Retry-After', result.retryAfter!);
      return res.status(429).json({
        error: 'Too Many Requests',
        message: `Rate limit exceeded. Try again in ${result.retryAfter} seconds.`,
        retryAfter: result.retryAfter,
      });
    }

    next();
  };
}
```

### Configuration

```typescript
// config/rate-limits.ts
export const rateLimits = {
  // Default limits
  default: {
    requests: 100,
    window: 60, // 1 minute
  },

  // Per-tier limits
  free: {
    requests: 10,
    window: 60,
  },

  pro: {
    requests: 100,
    window: 60,
  },

  enterprise: {
    requests: 1000,
    window: 60,
  },

  // Token limits (per hour)
  tokenLimits: {
    free: 10000,
    pro: 100000,
    enterprise: -1, // unlimited
  },
};
```

### Response Headers

```
X-RateLimit-Limit: 100
X-RateLimit-Remaining: 95
X-RateLimit-Reset: 2026-02-08T12:00:00Z
Retry-After: 30  (only on 429)
```

### Files to Create/Modify
- `apps/gateway/services/rate-limiter/index.ts`
- `apps/gateway/middleware/rate-limit.ts`
- `apps/gateway/config/rate-limits.ts`

## Dependencies

- Redis installed and configured
- User/API key identification in requests

## Definition of Done

- [ ] Rate limiting enforced correctly
- [ ] Headers returned on all responses
- [ ] 429 returned when limit exceeded
- [ ] Graceful handling of Redis failure
- [ ] Unit tests for limiter logic
- [ ] Load tests to verify limits
- [ ] Documentation for configuring limits

---

*Created: 2026-02-08*
