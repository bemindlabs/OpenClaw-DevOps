# US-014: Usage Analytics & Logging

## Story Details

| Field | Value |
|-------|-------|
| **Story ID** | US-014 |
| **Epic** | EPIC-GATEWAY |
| **Title** | Usage Analytics & Logging |
| **Priority** | Medium |
| **Story Points** | 5 |
| **Status** | Ready |
| **Assignee** | Unassigned |
| **Sprint** | Sprint 2 |

## User Story

**As a** platform operator,
**I want** comprehensive usage analytics and logging,
**So that** I can monitor system health, track costs, and understand usage patterns.

## Description

Implement a logging and analytics system that tracks all API requests, token usage, costs, and errors. Store data in MongoDB for historical analysis and emit real-time metrics to Prometheus for monitoring and alerting.

## Acceptance Criteria

- [ ] All API requests logged with metadata
- [ ] Token usage tracked per request
- [ ] Cost calculation per provider/model
- [ ] Error rates tracked and logged
- [ ] Response times measured and logged
- [ ] Prometheus metrics exported
- [ ] MongoDB storage for historical data
- [ ] Log retention policy implemented
- [ ] Sensitive data redacted from logs
- [ ] Dashboard-ready aggregations available

## Technical Notes

### IEEE Requirement References
- IEEE-STD-GW-002: Request Handling

### Request Logger

```typescript
// services/analytics/logger.ts
export interface RequestLog {
  id: string;
  timestamp: Date;
  userId?: string;
  apiKey?: string;
  provider: string;
  model: string;
  endpoint: string;
  method: string;

  // Request details
  promptTokens: number;
  completionTokens: number;
  totalTokens: number;

  // Response details
  statusCode: number;
  durationMs: number;
  error?: string;

  // Cost tracking
  estimatedCost: number;
  currency: string;
}

export class RequestLogger {
  private collection: Collection<RequestLog>;
  private metrics: MetricsClient;

  constructor(db: Db, metrics: MetricsClient) {
    this.collection = db.collection('request_logs');
    this.metrics = metrics;
  }

  async log(request: RequestLog): Promise<void> {
    // Store in MongoDB
    await this.collection.insertOne(request);

    // Emit Prometheus metrics
    this.metrics.histogram('http_request_duration_seconds', request.durationMs / 1000, {
      provider: request.provider,
      model: request.model,
      status: String(request.statusCode),
    });

    this.metrics.counter('llm_tokens_total', request.totalTokens, {
      provider: request.provider,
      model: request.model,
      type: 'total',
    });

    this.metrics.counter('llm_requests_total', 1, {
      provider: request.provider,
      model: request.model,
      status: String(request.statusCode),
    });

    if (request.error) {
      this.metrics.counter('llm_errors_total', 1, {
        provider: request.provider,
        error_type: this.classifyError(request.error),
      });
    }
  }
}
```

### Cost Calculator

```typescript
// services/analytics/cost-calculator.ts
export const PRICING: Record<string, Record<string, { input: number; output: number }>> = {
  openai: {
    'gpt-4': { input: 0.03, output: 0.06 },      // per 1K tokens
    'gpt-4-turbo': { input: 0.01, output: 0.03 },
    'gpt-3.5-turbo': { input: 0.0005, output: 0.0015 },
  },
  anthropic: {
    'claude-3-opus': { input: 0.015, output: 0.075 },
    'claude-3-sonnet': { input: 0.003, output: 0.015 },
    'claude-3-haiku': { input: 0.00025, output: 0.00125 },
  },
  // ... more providers
};

export function calculateCost(
  provider: string,
  model: string,
  promptTokens: number,
  completionTokens: number
): number {
  const pricing = PRICING[provider]?.[model];
  if (!pricing) return 0;

  const inputCost = (promptTokens / 1000) * pricing.input;
  const outputCost = (completionTokens / 1000) * pricing.output;

  return inputCost + outputCost;
}
```

### Aggregation Queries

```typescript
// services/analytics/aggregations.ts
export class AnalyticsService {
  async getDailyUsage(userId: string, startDate: Date, endDate: Date) {
    return this.collection.aggregate([
      {
        $match: {
          userId,
          timestamp: { $gte: startDate, $lte: endDate },
        },
      },
      {
        $group: {
          _id: {
            $dateToString: { format: '%Y-%m-%d', date: '$timestamp' },
          },
          totalRequests: { $sum: 1 },
          totalTokens: { $sum: '$totalTokens' },
          totalCost: { $sum: '$estimatedCost' },
          avgDuration: { $avg: '$durationMs' },
          errorCount: {
            $sum: { $cond: [{ $ne: ['$error', null] }, 1, 0] },
          },
        },
      },
      { $sort: { _id: 1 } },
    ]).toArray();
  }

  async getProviderBreakdown(userId: string, period: 'day' | 'week' | 'month') {
    // Return usage breakdown by provider
  }
}
```

### Prometheus Metrics

```
# Request metrics
http_request_duration_seconds{provider, model, status}
llm_requests_total{provider, model, status}
llm_tokens_total{provider, model, type}  # type: input|output|total
llm_errors_total{provider, error_type}

# Cost metrics
llm_cost_dollars_total{provider, model}

# Rate limit metrics
rate_limit_exceeded_total{user_tier}
```

### Files to Create/Modify
- `apps/gateway/services/analytics/logger.ts`
- `apps/gateway/services/analytics/cost-calculator.ts`
- `apps/gateway/services/analytics/aggregations.ts`
- `apps/gateway/middleware/request-logging.ts`

## Dependencies

- MongoDB for log storage
- Prometheus client library
- Request/response interceptor middleware

## Definition of Done

- [ ] All requests logged to MongoDB
- [ ] Prometheus metrics exposed at /metrics
- [ ] Cost calculation accurate for all providers
- [ ] Aggregation queries tested
- [ ] Sensitive data redaction verified
- [ ] Documentation for analytics API

---

*Created: 2026-02-08*
