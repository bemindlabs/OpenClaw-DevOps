# US-018: Chat Interface

## Story Details

| Field | Value |
|-------|-------|
| **Story ID** | US-018 |
| **Epic** | EPIC-ADMIN |
| **Title** | Chat Interface |
| **Priority** | Medium |
| **Story Points** | 8 |
| **Status** | Ready |
| **Assignee** | Unassigned |
| **Sprint** | Sprint 3 |

## User Story

**As an** administrator,
**I want** a chat interface to interact with the AI gateway,
**So that** I can test LLM integrations and manage the system through natural language.

## Description

Create a chat interface component that allows administrators to send messages to the AI gateway and receive streaming responses. Support for model selection, conversation history, and message formatting (code blocks, markdown).

## Acceptance Criteria

- [ ] Message input with send button
- [ ] Streaming message display
- [ ] Model selector dropdown
- [ ] Conversation history persisted per session
- [ ] Clear conversation button
- [ ] Code block syntax highlighting
- [ ] Markdown rendering in messages
- [ ] Copy message to clipboard
- [ ] Loading indicator during response
- [ ] Error handling and retry option
- [ ] Keyboard shortcuts (Enter to send, Shift+Enter for newline)

## Technical Notes

### IEEE Requirement References
- IEEE-STD-ADMIN-002: Real-time Features

### Message Interface

```typescript
// types/chat.ts
export interface Message {
  id: string;
  role: 'user' | 'assistant' | 'system';
  content: string;
  timestamp: Date;
  model?: string;
  error?: string;
}

export interface ChatState {
  messages: Message[];
  isStreaming: boolean;
  selectedModel: string;
}
```

### Chat Component

```tsx
// components/chat/chat-interface.tsx
export function ChatInterface() {
  const [messages, setMessages] = useState<Message[]>([]);
  const [input, setInput] = useState('');
  const [isStreaming, setIsStreaming] = useState(false);
  const [selectedModel, setSelectedModel] = useState('claude-3-sonnet');
  const socket = useSocket();

  const handleSend = async () => {
    if (!input.trim() || isStreaming) return;

    const userMessage: Message = {
      id: generateId(),
      role: 'user',
      content: input,
      timestamp: new Date(),
    };

    setMessages((prev) => [...prev, userMessage]);
    setInput('');
    setIsStreaming(true);

    // Create placeholder for assistant response
    const assistantMessage: Message = {
      id: generateId(),
      role: 'assistant',
      content: '',
      timestamp: new Date(),
      model: selectedModel,
    };
    setMessages((prev) => [...prev, assistantMessage]);

    // Send to gateway via WebSocket
    socket.emit('chat', {
      model: selectedModel,
      messages: messages.map(m => ({ role: m.role, content: m.content })),
    });
  };

  useEffect(() => {
    socket.on('chat:chunk', (data) => {
      setMessages((prev) => {
        const updated = [...prev];
        const lastMessage = updated[updated.length - 1];
        if (lastMessage.role === 'assistant') {
          lastMessage.content += data.content;
        }
        return updated;
      });
    });

    socket.on('chat:complete', () => {
      setIsStreaming(false);
    });

    socket.on('chat:error', (error) => {
      setIsStreaming(false);
      setMessages((prev) => {
        const updated = [...prev];
        const lastMessage = updated[updated.length - 1];
        if (lastMessage.role === 'assistant') {
          lastMessage.error = error.message;
        }
        return updated;
      });
    });

    return () => {
      socket.off('chat:chunk');
      socket.off('chat:complete');
      socket.off('chat:error');
    };
  }, [socket]);

  return (
    <div className="flex flex-col h-full">
      <ChatHeader
        selectedModel={selectedModel}
        onModelChange={setSelectedModel}
        onClear={() => setMessages([])}
      />
      <MessageList messages={messages} isStreaming={isStreaming} />
      <MessageInput
        value={input}
        onChange={setInput}
        onSend={handleSend}
        disabled={isStreaming}
      />
    </div>
  );
}
```

### Message Bubble Component

```tsx
// components/chat/message-bubble.tsx
export function MessageBubble({ message }: { message: Message }) {
  const isUser = message.role === 'user';

  return (
    <div className={cn(
      'flex gap-3 p-4',
      isUser ? 'bg-muted/50' : 'bg-background'
    )}>
      <Avatar className="h-8 w-8">
        {isUser ? (
          <User className="h-5 w-5" />
        ) : (
          <Bot className="h-5 w-5" />
        )}
      </Avatar>
      <div className="flex-1 space-y-2">
        <div className="flex items-center gap-2">
          <span className="font-medium">
            {isUser ? 'You' : 'Assistant'}
          </span>
          {message.model && (
            <Badge variant="outline" className="text-xs">
              {message.model}
            </Badge>
          )}
          <span className="text-xs text-muted-foreground">
            {format(message.timestamp, 'HH:mm')}
          </span>
        </div>
        <div className="prose prose-sm dark:prose-invert max-w-none">
          <ReactMarkdown
            components={{
              code: ({ node, inline, className, children, ...props }) => {
                if (inline) {
                  return <code className="bg-muted px-1 rounded">{children}</code>;
                }
                const match = /language-(\w+)/.exec(className || '');
                return (
                  <SyntaxHighlighter
                    language={match?.[1] || 'text'}
                    style={oneDark}
                    {...props}
                  >
                    {String(children).replace(/\n$/, '')}
                  </SyntaxHighlighter>
                );
              },
            }}
          >
            {message.content}
          </ReactMarkdown>
        </div>
        {message.error && (
          <Alert variant="destructive">
            <AlertDescription>{message.error}</AlertDescription>
          </Alert>
        )}
      </div>
      <Button
        variant="ghost"
        size="icon"
        onClick={() => navigator.clipboard.writeText(message.content)}
      >
        <Copy className="h-4 w-4" />
      </Button>
    </div>
  );
}
```

### Message Input Component

```tsx
// components/chat/message-input.tsx
export function MessageInput({
  value,
  onChange,
  onSend,
  disabled,
}: MessageInputProps) {
  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      onSend();
    }
  };

  return (
    <div className="border-t p-4">
      <div className="flex gap-2">
        <Textarea
          value={value}
          onChange={(e) => onChange(e.target.value)}
          onKeyDown={handleKeyDown}
          placeholder="Type a message..."
          className="min-h-[80px] resize-none"
          disabled={disabled}
        />
        <Button
          onClick={onSend}
          disabled={disabled || !value.trim()}
          className="self-end"
        >
          {disabled ? (
            <Loader2 className="h-4 w-4 animate-spin" />
          ) : (
            <Send className="h-4 w-4" />
          )}
        </Button>
      </div>
      <p className="text-xs text-muted-foreground mt-2">
        Press Enter to send, Shift+Enter for new line
      </p>
    </div>
  );
}
```

### Files to Create/Modify
- `apps/assistant/components/chat/chat-interface.tsx`
- `apps/assistant/components/chat/message-bubble.tsx`
- `apps/assistant/components/chat/message-list.tsx`
- `apps/assistant/components/chat/message-input.tsx`
- `apps/assistant/components/chat/chat-header.tsx`
- `apps/assistant/app/dashboard/chat/page.tsx`

## Dependencies

- WebSocket streaming support (US-013)
- react-markdown and react-syntax-highlighter

## Definition of Done

- [ ] Messages send and stream correctly
- [ ] Model selection works
- [ ] Markdown/code rendering works
- [ ] Copy to clipboard works
- [ ] Error handling implemented
- [ ] Keyboard shortcuts work
- [ ] Performance acceptable with long conversations

---

*Created: 2026-02-08*
