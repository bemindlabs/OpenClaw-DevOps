# US-013: WebSocket Streaming Support

## Story Details

| Field | Value |
|-------|-------|
| **Story ID** | US-013 |
| **Epic** | EPIC-GATEWAY |
| **Title** | WebSocket Streaming Support |
| **Priority** | High |
| **Story Points** | 5 |
| **Status** | Ready |
| **Assignee** | Unassigned |
| **Sprint** | Sprint 2 |

## User Story

**As a** developer,
**I want** real-time streaming of LLM responses via WebSocket,
**So that** users see responses as they're generated rather than waiting for completion.

## Description

Implement WebSocket support for streaming LLM responses in real-time. This includes establishing persistent connections, handling authentication, forwarding streaming responses from providers, and managing connection lifecycle with proper error handling and reconnection logic.

## Acceptance Criteria

- [ ] WebSocket endpoint available at `/ws`
- [ ] Authentication required for connection
- [ ] Streaming responses delivered in real-time
- [ ] Support for multiple concurrent connections
- [ ] Heartbeat/ping-pong to detect dead connections
- [ ] Automatic cleanup of stale connections
- [ ] Error messages sent through socket
- [ ] Graceful handling of provider stream errors
- [ ] Reconnection guidance in close messages
- [ ] Metrics for connection count and throughput

## Technical Notes

### IEEE Requirement References
- IEEE-STD-GW-004: Streaming Support

### Socket.IO Implementation

```typescript
// socket/index.ts
import { Server } from 'socket.io';
import { createAdapter } from '@socket.io/redis-adapter';

export function setupSocket(httpServer: HttpServer, redis: Redis) {
  const io = new Server(httpServer, {
    cors: {
      origin: process.env.ALLOWED_ORIGINS?.split(',') || '*',
      credentials: true,
    },
    pingTimeout: 60000,
    pingInterval: 25000,
  });

  // Redis adapter for horizontal scaling
  const pubClient = redis.duplicate();
  const subClient = redis.duplicate();
  io.adapter(createAdapter(pubClient, subClient));

  // Authentication middleware
  io.use(async (socket, next) => {
    const token = socket.handshake.auth.token;
    try {
      const user = await verifyToken(token);
      socket.data.user = user;
      next();
    } catch (error) {
      next(new Error('Authentication failed'));
    }
  });

  io.on('connection', (socket) => {
    logger.info(`Client connected: ${socket.id}`);
    metrics.increment('websocket_connections');

    socket.on('chat', async (request: ChatRequest) => {
      try {
        await handleStreamingChat(socket, request);
      } catch (error) {
        socket.emit('error', { message: error.message });
      }
    });

    socket.on('disconnect', (reason) => {
      logger.info(`Client disconnected: ${socket.id}, reason: ${reason}`);
      metrics.decrement('websocket_connections');
    });
  });

  return io;
}
```

### Streaming Handler

```typescript
// socket/handlers/chat.ts
async function handleStreamingChat(socket: Socket, request: ChatRequest) {
  const requestId = generateRequestId();
  socket.emit('chat:start', { requestId });

  const provider = router.getProvider(request);
  const stream = provider.chatStream(request);

  try {
    for await (const chunk of stream) {
      socket.emit('chat:chunk', {
        requestId,
        content: chunk.content,
        finishReason: chunk.finishReason,
      });
    }

    socket.emit('chat:complete', {
      requestId,
      usage: await calculateUsage(request),
    });
  } catch (error) {
    socket.emit('chat:error', {
      requestId,
      error: error.message,
      retryable: isRetryableError(error),
    });
  }
}
```

### Client Integration

```typescript
// Example client usage
import { io } from 'socket.io-client';

const socket = io('wss://openclaw.your-domain.com', {
  auth: { token: 'your-api-token' },
  reconnection: true,
  reconnectionAttempts: 5,
  reconnectionDelay: 1000,
});

socket.on('connect', () => {
  console.log('Connected to OpenClaw Gateway');
});

socket.on('chat:chunk', (data) => {
  // Append content to UI
  appendToResponse(data.content);
});

socket.on('chat:complete', (data) => {
  console.log('Chat complete', data.usage);
});

socket.on('chat:error', (data) => {
  console.error('Chat error', data.error);
  if (data.retryable) {
    // Implement retry logic
  }
});

// Send chat request
socket.emit('chat', {
  model: 'claude-3',
  messages: [{ role: 'user', content: 'Hello!' }],
});
```

### Message Protocol

```typescript
// Events from client to server
interface ClientEvents {
  'chat': ChatRequest;
  'abort': { requestId: string };
}

// Events from server to client
interface ServerEvents {
  'chat:start': { requestId: string };
  'chat:chunk': {
    requestId: string;
    content: string;
    finishReason?: string;
  };
  'chat:complete': {
    requestId: string;
    usage: { promptTokens: number; completionTokens: number };
  };
  'chat:error': {
    requestId: string;
    error: string;
    retryable: boolean;
  };
}
```

### Files to Create/Modify
- `apps/gateway/socket/index.ts`
- `apps/gateway/socket/handlers/chat.ts`
- `apps/gateway/socket/middleware/auth.ts`

## Dependencies

- Socket.IO installed
- Redis for horizontal scaling
- Provider streaming support (US-010)

## Definition of Done

- [ ] WebSocket connections work with authentication
- [ ] Streaming responses delivered in real-time
- [ ] Multiple concurrent connections handled
- [ ] Connection cleanup working
- [ ] Error handling tested
- [ ] Client example documentation
- [ ] Load testing with 100+ concurrent connections

---

*Created: 2026-02-08*
